# Kotlin JDSL은 jOOQ, QueryDSL와 무엇이 다른가요?

jOOQ와 QueryDSL과 다르게 Kotlin JDSL의 경우 쿼리 작성을 위해 `Metadata Model(코드 제너레이션)`을 생성하지 않습니다.

코드 제너레이션 방식을 사용하면 몇 가지 단점이 존재합니다.

1. 프로젝트 초기 설정 복잡도 증가
2. 통상적인 빌드 프로세스 과정에 메타데이타터 생성 과정 추가

2번의 예시로 다음과 같은 수고로움이 있습니다:

```
1. 테이블과 엔티티 수정
2. 엔티티 수정으로 컴파일 오류 발생
3. 메타데이터를 다시 생성하기 위해 Maven 또는 Gradle 작업 실행
4. 수정된 엔티티를 기반으로 쿼리 작성
```

그러면 아마도 우리는 JPQL을 생각해볼 수도 있지만 이는 좋은 생각이 아닐 수 있습니다.

JPQL은 문자열 기반의 쿼리 작성 방식을 사용하기 때문에, 컴파일 시점에 오류를 감지할 수 없습니다.

하지만 Kotlin JDSL은 코드 제너레이션 방식과 문자열 기반 작성이 아닌 순수한 코드 기반으로 쿼리를 작성합니다.

즉, 엔티티나 필드 이름을 수정하는 즉시 쿼리 코드에 반영이 되어 위와 같은 불편함이 존재하지 않습니다.

또한 JPQL과 같이 ORM 기반의 객체지향 쿼리를 채택하고 있어서 다형성, Fetch 조인 등의 스펙을 지원합니다.

따라서 쿼리를 작성하는 방식 또한 테이블/컬럼 자체에 쿼리를 하는 것이 아닌 객체명과 필드에 의존하여 쿼리를 합니다.

