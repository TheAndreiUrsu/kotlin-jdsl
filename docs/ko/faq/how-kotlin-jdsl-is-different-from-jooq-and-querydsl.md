# Kotlin JDSL은 jOOQ, QueryDSL와 무엇이 다른가요?

jOOq와 QueryDSL과 다르게 Kotlin JDSL의 경우 쿼리 작성을 위해 `Metadata Model(코드 제너레이션)`을 생성하지 않습니다.

코드 제너레이션 방식을 사용하면 다음과 같은 수고로움이 있습니다:

```
테이블과 엔티티 수정 →
엔티티 수정으로 컴파일 오류 발생 →
메타데이터를 다시 생성하기 위해 Manven 또는 Gradle 작업 실행 →
수정된 엔티티를 기반으로 쿼리 작성
```

그러면 아마도 우리는 JPQL을 생각해볼 수도 있지만 이는 좋은 생각이 아닐 수 있습니다.

JPQL은 문자열 기반의 쿼리 작성 방식을 사용하기 때문에, 컴파일 시점에 오류를 감지할 수 없습니다.

하지만 Kotlin JDSL은 코드 제너레이션 방식과 문자열 기반 작성이 아닌 순수한 코드 기반으로 쿼리를 작성합니다.

즉, 엔티티나 필드 이름을 수정하는 즉시 쿼리 코드에 반영이 되어 위와 같은 불편함이 존재하지 않습니다.

또 JPQL과 같이 ORM 기반의 객체지향 쿼리를 채택하고 있어서 다형성, Fetch 조인 등의 스펙을 지원합니다.

따라서 쿼리를 작성하는 방식 또한 테이블/컬럼 자체에 쿼리를 하는 것이 아닌 객체명과 필드에 의존하여 쿼리를 합니다.

아래는 Kotlin JDSL과 QueryDSL, jOOQ의 차이점을 비교한 표입니다.

|          | Kotlin JDSL | QueryDSL                 | jOOQ                     |
|----------|-------------|--------------------------|--------------------------|
| 코드 제너레이션 | ❌           | ✅                        | ✅                        |
| 쿼리 작성 방식 | JPQL        | SQL, JPQL                | SQL                      |
| 언어 지원    | Kotlin      | Java, Kotlin 등 모든 JVM 언어 | Java, Kotlin 등 모든 JVM 언어 |
| 타입 안정성   | ✅           | ✅                        | ✅                        |
