# Kotlin JDSL은 jOOQ, QueryDSL와 무엇이 다른가요?

jOOq와 QueryDSL과 다르게 Kotlin JDSL의 경우 쿼리 작성을 위해 `Metadata Model(코드 제너레이션)`을 생성하지 않습니다.

코드 제너레이션 방식을 사용하면 다음과 같은 수고로움이 있습니다.

```
테이블 / 엔티티 수정 →
코드와 메타 코드 불일치로 인한 컴파일 에러 →
수정한 코드와 연관된 모든 코드를 컴파일이 동작하게끔 주석 처리등을 하여 임시로 변경 →
코드 재생성 →
컴파일 통과를 하기 위해 처리한 임시 코드를 지우고 정상 동작하는 코드로 변경
```

또 JPQL의 경우 문자열 기반의 쿼리 작성 방식을 사용하고 있기 때문에, 컴파일은 통과할 수 있지만 웹 어플리케이션 실행 시점에 오류가 발생할 소지가 있습니다.

하지만 Line-JDSL은 문자열 기반 작성과 코드 제너레이션 방식을 사용하는 것이 아닌 순수 코드 기반으로 쿼리 작성이 가능합니다.

즉, 엔티티나 필드 이름을 수정하는 즉시 쿼리 코드에 반영이 되어 컴파일 및 실행 가능합니다.

또 JPQL과 같이 ORM 기반의 객체지향 쿼리를 채택하고 있어서 다형성, Fetch 조인 등의 스펙을 지원합니다.

따라서 쿼리를 작성하는 방식 또한 테이블/컬럼 자체에 쿼리를 하는 것이 아닌 객체명과 필드에 의존하여 쿼리를 합니다.

아래는 Kotlin JDSL과 QueryDSL, jOOQ의 차이점을 비교한 표입니다.

|          | Kotlin JDSL | QueryDSL                 | jOOQ                     |
|----------|-------------|--------------------------|--------------------------|
| 코드 제너레이션 | ❌           | ✅                        | ✅                        |
| 쿼리 작성 방식 | JPQL        | SQL, JPQL                | SQL                      |
| 언어 지원    | Kotlin      | Java, Kotlin 등 모든 JVM 언어 | Java, Kotlin 등 모든 JVM 언어 |
| 타입 안정성   | ✅           | ✅                        | ✅                        |
